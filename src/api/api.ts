/* tslint:disable */
/* eslint-disable */
/**
 * EntryPoint
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from './base';

/**
 *
 * @export
 * @interface BatchItem
 */
export interface BatchItem {
  /**
   *
   * @type {string}
   * @memberof BatchItem
   */
  id?: string | null;
  /**
   *
   * @type {string}
   * @memberof BatchItem
   */
  cropId?: string | null;
  /**
   *
   * @type {string}
   * @memberof BatchItem
   */
  commonName?: string | null;
  /**
   *
   * @type {number}
   * @memberof BatchItem
   */
  amount?: number;
  /**
   *
   * @type {number}
   * @memberof BatchItem
   */
  databaseId?: number;
  /**
   *
   * @type {string}
   * @memberof BatchItem
   */
  location?: string | null;
  /**
   *
   * @type {string}
   * @memberof BatchItem
   */
  planted?: string;
  /**
   *
   * @type {string}
   * @memberof BatchItem
   */
  lastWatered?: string | null;
  /**
   *
   * @type {string}
   * @memberof BatchItem
   */
  lastFertilized?: string | null;
  /**
   *
   * @type {string}
   * @memberof BatchItem
   */
  lastPruned?: string | null;
  /**
   *
   * @type {string}
   * @memberof BatchItem
   */
  lastHarvested?: string | null;
  /**
   *
   * @type {string}
   * @memberof BatchItem
   */
  notes?: string | null;
}
/**
 *
 * @export
 * @interface CropItem
 */
export interface CropItem {
  /**
   *
   * @type {string}
   * @memberof CropItem
   */
  commonName?: string | null;
  /**
   *
   * @type {string}
   * @memberof CropItem
   */
  id?: string;
  /**
   *
   * @type {number}
   * @memberof CropItem
   */
  waterCycle?: number;
  /**
   *
   * @type {number}
   * @memberof CropItem
   */
  pruningCycle?: number;
  /**
   *
   * @type {number}
   * @memberof CropItem
   */
  fertilizationCycle?: number;
  /**
   *
   * @type {number}
   * @memberof CropItem
   */
  harvestCycle?: number;
  /**
   *
   * @type {string}
   * @memberof CropItem
   */
  notes?: string | null;
  /**
   *
   * @type {string}
   * @memberof CropItem
   */
  harvestStart?: CropItemHarvestStartEnum;
  /**
   *
   * @type {string}
   * @memberof CropItem
   */
  harvestEnd?: CropItemHarvestEndEnum;
  /**
   *
   * @type {string}
   * @memberof CropItem
   */
  pruningStart?: CropItemPruningStartEnum;
  /**
   *
   * @type {string}
   * @memberof CropItem
   */
  pruningEnd?: CropItemPruningEndEnum;
  /**
   *
   * @type {string}
   * @memberof CropItem
   */
  fertilizingStart?: CropItemFertilizingStartEnum;
  /**
   *
   * @type {string}
   * @memberof CropItem
   */
  fertilizingEnd?: CropItemFertilizingEndEnum;
  /**
   *
   * @type {number}
   * @memberof CropItem
   */
  phMin?: number;
  /**
   *
   * @type {number}
   * @memberof CropItem
   */
  phMax?: number;
  /**
   *
   * @type {number}
   * @memberof CropItem
   */
  temperatureMin?: number;
  /**
   *
   * @type {number}
   * @memberof CropItem
   */
  temperatureMax?: number;
}

export const CropItemHarvestStartEnum = {
  January: 'January',
  February: 'February',
  March: 'March',
  April: 'April',
  May: 'May',
  June: 'June',
  July: 'July',
  August: 'August',
  September: 'September',
  October: 'October',
  November: 'November',
  December: 'December',
} as const;

export type CropItemHarvestStartEnum =
  (typeof CropItemHarvestStartEnum)[keyof typeof CropItemHarvestStartEnum];
export const CropItemHarvestEndEnum = {
  January: 'January',
  February: 'February',
  March: 'March',
  April: 'April',
  May: 'May',
  June: 'June',
  July: 'July',
  August: 'August',
  September: 'September',
  October: 'October',
  November: 'November',
  December: 'December',
} as const;

export type CropItemHarvestEndEnum =
  (typeof CropItemHarvestEndEnum)[keyof typeof CropItemHarvestEndEnum];
export const CropItemPruningStartEnum = {
  January: 'January',
  February: 'February',
  March: 'March',
  April: 'April',
  May: 'May',
  June: 'June',
  July: 'July',
  August: 'August',
  September: 'September',
  October: 'October',
  November: 'November',
  December: 'December',
} as const;

export type CropItemPruningStartEnum =
  (typeof CropItemPruningStartEnum)[keyof typeof CropItemPruningStartEnum];
export const CropItemPruningEndEnum = {
  January: 'January',
  February: 'February',
  March: 'March',
  April: 'April',
  May: 'May',
  June: 'June',
  July: 'July',
  August: 'August',
  September: 'September',
  October: 'October',
  November: 'November',
  December: 'December',
} as const;

export type CropItemPruningEndEnum =
  (typeof CropItemPruningEndEnum)[keyof typeof CropItemPruningEndEnum];
export const CropItemFertilizingStartEnum = {
  January: 'January',
  February: 'February',
  March: 'March',
  April: 'April',
  May: 'May',
  June: 'June',
  July: 'July',
  August: 'August',
  September: 'September',
  October: 'October',
  November: 'November',
  December: 'December',
} as const;

export type CropItemFertilizingStartEnum =
  (typeof CropItemFertilizingStartEnum)[keyof typeof CropItemFertilizingStartEnum];
export const CropItemFertilizingEndEnum = {
  January: 'January',
  February: 'February',
  March: 'March',
  April: 'April',
  May: 'May',
  June: 'June',
  July: 'July',
  August: 'August',
  September: 'September',
  October: 'October',
  November: 'November',
  December: 'December',
} as const;

export type CropItemFertilizingEndEnum =
  (typeof CropItemFertilizingEndEnum)[keyof typeof CropItemFertilizingEndEnum];

/**
 *
 * @export
 * @interface FieldItem
 */
export interface FieldItem {
  /**
   *
   * @type {string}
   * @memberof FieldItem
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof FieldItem
   */
  name?: string | null;
  /**
   *
   * @type {string}
   * @memberof FieldItem
   */
  notes?: string | null;
  /**
   *
   * @type {number}
   * @memberof FieldItem
   */
  latitude?: number;
  /**
   *
   * @type {number}
   * @memberof FieldItem
   */
  longitude?: number;
}
/**
 *
 * @export
 * @interface ReadingItem
 */
export interface ReadingItem {
  /**
   *
   * @type {string}
   * @memberof ReadingItem
   */
  title?: string | null;
  /**
   *
   * @type {string}
   * @memberof ReadingItem
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ReadingItem
   */
  batchId?: string;
  /**
   *
   * @type {string}
   * @memberof ReadingItem
   */
  soilDryness?: ReadingItemSoilDrynessEnum;
  /**
   *
   * @type {number}
   * @memberof ReadingItem
   */
  soilPH?: number;
  /**
   *
   * @type {string}
   * @memberof ReadingItem
   */
  healthStatus?: ReadingItemHealthStatusEnum;
  /**
   *
   * @type {string}
   * @memberof ReadingItem
   */
  growthStage?: ReadingItemGrowthStageEnum;
  /**
   *
   * @type {number}
   * @memberof ReadingItem
   */
  temperature?: number;
  /**
   *
   * @type {string}
   * @memberof ReadingItem
   */
  notes?: string | null;
  /**
   *
   * @type {string}
   * @memberof ReadingItem
   */
  date?: string | null;
}

export const ReadingItemSoilDrynessEnum = {
  VeryWet: 'VeryWet',
  Wet: 'Wet',
  Moist: 'Moist',
  Dry: 'Dry',
  VeryDry: 'VeryDry',
} as const;

export type ReadingItemSoilDrynessEnum =
  (typeof ReadingItemSoilDrynessEnum)[keyof typeof ReadingItemSoilDrynessEnum];
export const ReadingItemHealthStatusEnum = {
  Poor: 'Poor',
  Fair: 'Fair',
  Good: 'Good',
  VeryGood: 'VeryGood',
  Excellent: 'Excellent',
} as const;

export type ReadingItemHealthStatusEnum =
  (typeof ReadingItemHealthStatusEnum)[keyof typeof ReadingItemHealthStatusEnum];
export const ReadingItemGrowthStageEnum = {
  Germination: 'Germination',
  Seedling: 'Seedling',
  Vegetative: 'Vegetative',
  Budding: 'Budding',
  Flowering: 'Flowering',
  Fruiting: 'Fruiting',
  Maturity: 'Maturity',
} as const;

export type ReadingItemGrowthStageEnum =
  (typeof ReadingItemGrowthStageEnum)[keyof typeof ReadingItemGrowthStageEnum];

/**
 *
 * @export
 * @interface TodoItem
 */
export interface TodoItem {
  /**
   *
   * @type {string}
   * @memberof TodoItem
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof TodoItem
   */
  batchId?: string;
  /**
   *
   * @type {string}
   * @memberof TodoItem
   */
  title?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof TodoItem
   */
  autoGenerated?: boolean;
  /**
   *
   * @type {string}
   * @memberof TodoItem
   */
  todoStatus?: TodoItemTodoStatusEnum;
  /**
   *
   * @type {string}
   * @memberof TodoItem
   */
  dueDate?: string;
  /**
   *
   * @type {string}
   * @memberof TodoItem
   */
  priority?: TodoItemPriorityEnum;
  /**
   *
   * @type {string}
   * @memberof TodoItem
   */
  category?: TodoItemCategoryEnum;
  /**
   *
   * @type {string}
   * @memberof TodoItem
   */
  notes?: string | null;
}

export const TodoItemTodoStatusEnum = {
  NotStarted: 'NotStarted',
  InProgress: 'InProgress',
  Completed: 'Completed',
  OnHold: 'OnHold',
  Cancelled: 'Cancelled',
} as const;

export type TodoItemTodoStatusEnum =
  (typeof TodoItemTodoStatusEnum)[keyof typeof TodoItemTodoStatusEnum];
export const TodoItemPriorityEnum = {
  High: 'High',
  Medium: 'Medium',
  Low: 'Low',
} as const;

export type TodoItemPriorityEnum =
  (typeof TodoItemPriorityEnum)[keyof typeof TodoItemPriorityEnum];
export const TodoItemCategoryEnum = {
  Fertilize: 'Fertilize',
  Harvest: 'Harvest',
  Prune: 'Prune',
  Water: 'Water',
  Sow: 'Sow',
  Measure: 'Measure',
  Other: 'Other',
} as const;

export type TodoItemCategoryEnum =
  (typeof TodoItemCategoryEnum)[keyof typeof TodoItemCategoryEnum];

/**
 * BatchApi - axios parameter creator
 * @export
 */
export const BatchApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiBatchIdDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiBatchIdDelete', 'id', id);
      const localVarPath = `/api/Batch/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiBatchIdGet: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiBatchIdGet', 'id', id);
      const localVarPath = `/api/Batch/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {BatchItem} [batchItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiBatchIdPut: async (
      id: string,
      batchItem?: BatchItem,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiBatchIdPut', 'id', id);
      const localVarPath = `/api/Batch/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        batchItem,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {BatchItem} [batchItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiBatchPost: async (
      batchItem?: BatchItem,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/Batch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        batchItem,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBatches: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/Batch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BatchApi - functional programming interface
 * @export
 */
export const BatchApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BatchApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiBatchIdDelete(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiBatchIdDelete(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BatchApi.apiBatchIdDelete']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiBatchIdGet(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchItem>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiBatchIdGet(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BatchApi.apiBatchIdGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {BatchItem} [batchItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiBatchIdPut(
      id: string,
      batchItem?: BatchItem,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiBatchIdPut(
        id,
        batchItem,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BatchApi.apiBatchIdPut']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {BatchItem} [batchItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiBatchPost(
      batchItem?: BatchItem,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiBatchPost(
        batchItem,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BatchApi.apiBatchPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBatches(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<BatchItem>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getBatches(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BatchApi.getBatches']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * BatchApi - factory interface
 * @export
 */
export const BatchApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = BatchApiFp(configuration);
  return {
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiBatchIdDelete(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .apiBatchIdDelete(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiBatchIdGet(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<BatchItem> {
      return localVarFp
        .apiBatchIdGet(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {BatchItem} [batchItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiBatchIdPut(
      id: string,
      batchItem?: BatchItem,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .apiBatchIdPut(id, batchItem, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {BatchItem} [batchItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiBatchPost(
      batchItem?: BatchItem,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .apiBatchPost(batchItem, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBatches(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<BatchItem>> {
      return localVarFp
        .getBatches(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * BatchApi - object-oriented interface
 * @export
 * @class BatchApi
 * @extends {BaseAPI}
 */
export class BatchApi extends BaseAPI {
  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchApi
   */
  public apiBatchIdDelete(id: string, options?: RawAxiosRequestConfig) {
    return BatchApiFp(this.configuration)
      .apiBatchIdDelete(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchApi
   */
  public apiBatchIdGet(id: string, options?: RawAxiosRequestConfig) {
    return BatchApiFp(this.configuration)
      .apiBatchIdGet(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {BatchItem} [batchItem]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchApi
   */
  public apiBatchIdPut(
    id: string,
    batchItem?: BatchItem,
    options?: RawAxiosRequestConfig,
  ) {
    return BatchApiFp(this.configuration)
      .apiBatchIdPut(id, batchItem, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {BatchItem} [batchItem]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchApi
   */
  public apiBatchPost(batchItem?: BatchItem, options?: RawAxiosRequestConfig) {
    return BatchApiFp(this.configuration)
      .apiBatchPost(batchItem, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchApi
   */
  public getBatches(options?: RawAxiosRequestConfig) {
    return BatchApiFp(this.configuration)
      .getBatches(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CropApi - axios parameter creator
 * @export
 */
export const CropApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCropIdDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiCropIdDelete', 'id', id);
      const localVarPath = `/api/Crop/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCropIdGet: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiCropIdGet', 'id', id);
      const localVarPath = `/api/Crop/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {CropItem} [cropItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCropIdPut: async (
      id: string,
      cropItem?: CropItem,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiCropIdPut', 'id', id);
      const localVarPath = `/api/Crop/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        cropItem,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CropItem} [cropItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCropPost: async (
      cropItem?: CropItem,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/Crop`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        cropItem,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCrops: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/Crop`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CropApi - functional programming interface
 * @export
 */
export const CropApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CropApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiCropIdDelete(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiCropIdDelete(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CropApi.apiCropIdDelete']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiCropIdGet(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CropItem>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiCropIdGet(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CropApi.apiCropIdGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {CropItem} [cropItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiCropIdPut(
      id: string,
      cropItem?: CropItem,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiCropIdPut(
        id,
        cropItem,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CropApi.apiCropIdPut']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {CropItem} [cropItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiCropPost(
      cropItem?: CropItem,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiCropPost(
        cropItem,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CropApi.apiCropPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCrops(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<CropItem>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCrops(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CropApi.getCrops']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * CropApi - factory interface
 * @export
 */
export const CropApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = CropApiFp(configuration);
  return {
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCropIdDelete(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .apiCropIdDelete(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCropIdGet(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CropItem> {
      return localVarFp
        .apiCropIdGet(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {CropItem} [cropItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCropIdPut(
      id: string,
      cropItem?: CropItem,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .apiCropIdPut(id, cropItem, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CropItem} [cropItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCropPost(
      cropItem?: CropItem,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .apiCropPost(cropItem, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCrops(options?: RawAxiosRequestConfig): AxiosPromise<Array<CropItem>> {
      return localVarFp
        .getCrops(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CropApi - object-oriented interface
 * @export
 * @class CropApi
 * @extends {BaseAPI}
 */
export class CropApi extends BaseAPI {
  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CropApi
   */
  public apiCropIdDelete(id: string, options?: RawAxiosRequestConfig) {
    return CropApiFp(this.configuration)
      .apiCropIdDelete(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CropApi
   */
  public apiCropIdGet(id: string, options?: RawAxiosRequestConfig) {
    return CropApiFp(this.configuration)
      .apiCropIdGet(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {CropItem} [cropItem]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CropApi
   */
  public apiCropIdPut(
    id: string,
    cropItem?: CropItem,
    options?: RawAxiosRequestConfig,
  ) {
    return CropApiFp(this.configuration)
      .apiCropIdPut(id, cropItem, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CropItem} [cropItem]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CropApi
   */
  public apiCropPost(cropItem?: CropItem, options?: RawAxiosRequestConfig) {
    return CropApiFp(this.configuration)
      .apiCropPost(cropItem, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CropApi
   */
  public getCrops(options?: RawAxiosRequestConfig) {
    return CropApiFp(this.configuration)
      .getCrops(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FieldApi - axios parameter creator
 * @export
 */
export const FieldApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiFieldIdDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiFieldIdDelete', 'id', id);
      const localVarPath = `/api/Field/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiFieldIdGet: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiFieldIdGet', 'id', id);
      const localVarPath = `/api/Field/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {FieldItem} [fieldItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiFieldIdPut: async (
      id: string,
      fieldItem?: FieldItem,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiFieldIdPut', 'id', id);
      const localVarPath = `/api/Field/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        fieldItem,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {FieldItem} [fieldItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiFieldPost: async (
      fieldItem?: FieldItem,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/Field`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        fieldItem,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFields: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/Field`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FieldApi - functional programming interface
 * @export
 */
export const FieldApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FieldApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiFieldIdDelete(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiFieldIdDelete(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FieldApi.apiFieldIdDelete']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiFieldIdGet(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FieldItem>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiFieldIdGet(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FieldApi.apiFieldIdGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {FieldItem} [fieldItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiFieldIdPut(
      id: string,
      fieldItem?: FieldItem,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiFieldIdPut(
        id,
        fieldItem,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FieldApi.apiFieldIdPut']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {FieldItem} [fieldItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiFieldPost(
      fieldItem?: FieldItem,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiFieldPost(
        fieldItem,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FieldApi.apiFieldPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFields(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<FieldItem>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFields(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FieldApi.getFields']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * FieldApi - factory interface
 * @export
 */
export const FieldApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = FieldApiFp(configuration);
  return {
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiFieldIdDelete(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .apiFieldIdDelete(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiFieldIdGet(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<FieldItem> {
      return localVarFp
        .apiFieldIdGet(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {FieldItem} [fieldItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiFieldIdPut(
      id: string,
      fieldItem?: FieldItem,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .apiFieldIdPut(id, fieldItem, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {FieldItem} [fieldItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiFieldPost(
      fieldItem?: FieldItem,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .apiFieldPost(fieldItem, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFields(options?: RawAxiosRequestConfig): AxiosPromise<Array<FieldItem>> {
      return localVarFp
        .getFields(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * FieldApi - object-oriented interface
 * @export
 * @class FieldApi
 * @extends {BaseAPI}
 */
export class FieldApi extends BaseAPI {
  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FieldApi
   */
  public apiFieldIdDelete(id: string, options?: RawAxiosRequestConfig) {
    return FieldApiFp(this.configuration)
      .apiFieldIdDelete(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FieldApi
   */
  public apiFieldIdGet(id: string, options?: RawAxiosRequestConfig) {
    return FieldApiFp(this.configuration)
      .apiFieldIdGet(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {FieldItem} [fieldItem]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FieldApi
   */
  public apiFieldIdPut(
    id: string,
    fieldItem?: FieldItem,
    options?: RawAxiosRequestConfig,
  ) {
    return FieldApiFp(this.configuration)
      .apiFieldIdPut(id, fieldItem, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {FieldItem} [fieldItem]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FieldApi
   */
  public apiFieldPost(fieldItem?: FieldItem, options?: RawAxiosRequestConfig) {
    return FieldApiFp(this.configuration)
      .apiFieldPost(fieldItem, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FieldApi
   */
  public getFields(options?: RawAxiosRequestConfig) {
    return FieldApiFp(this.configuration)
      .getFields(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ReadingApi - axios parameter creator
 * @export
 */
export const ReadingApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReadingIdDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiReadingIdDelete', 'id', id);
      const localVarPath = `/api/Reading/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReadingIdGet: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiReadingIdGet', 'id', id);
      const localVarPath = `/api/Reading/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {ReadingItem} [readingItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReadingIdPut: async (
      id: string,
      readingItem?: ReadingItem,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiReadingIdPut', 'id', id);
      const localVarPath = `/api/Reading/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        readingItem,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {ReadingItem} [readingItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReadingPost: async (
      readingItem?: ReadingItem,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/Reading`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        readingItem,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReadings: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/Reading`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ReadingApi - functional programming interface
 * @export
 */
export const ReadingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ReadingApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiReadingIdDelete(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiReadingIdDelete(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ReadingApi.apiReadingIdDelete']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiReadingIdGet(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadingItem>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiReadingIdGet(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ReadingApi.apiReadingIdGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {ReadingItem} [readingItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiReadingIdPut(
      id: string,
      readingItem?: ReadingItem,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiReadingIdPut(
        id,
        readingItem,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ReadingApi.apiReadingIdPut']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {ReadingItem} [readingItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiReadingPost(
      readingItem?: ReadingItem,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiReadingPost(
        readingItem,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ReadingApi.apiReadingPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getReadings(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ReadingItem>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getReadings(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ReadingApi.getReadings']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ReadingApi - factory interface
 * @export
 */
export const ReadingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ReadingApiFp(configuration);
  return {
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReadingIdDelete(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .apiReadingIdDelete(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReadingIdGet(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ReadingItem> {
      return localVarFp
        .apiReadingIdGet(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {ReadingItem} [readingItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReadingIdPut(
      id: string,
      readingItem?: ReadingItem,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .apiReadingIdPut(id, readingItem, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {ReadingItem} [readingItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReadingPost(
      readingItem?: ReadingItem,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .apiReadingPost(readingItem, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReadings(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ReadingItem>> {
      return localVarFp
        .getReadings(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ReadingApi - object-oriented interface
 * @export
 * @class ReadingApi
 * @extends {BaseAPI}
 */
export class ReadingApi extends BaseAPI {
  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReadingApi
   */
  public apiReadingIdDelete(id: string, options?: RawAxiosRequestConfig) {
    return ReadingApiFp(this.configuration)
      .apiReadingIdDelete(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReadingApi
   */
  public apiReadingIdGet(id: string, options?: RawAxiosRequestConfig) {
    return ReadingApiFp(this.configuration)
      .apiReadingIdGet(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {ReadingItem} [readingItem]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReadingApi
   */
  public apiReadingIdPut(
    id: string,
    readingItem?: ReadingItem,
    options?: RawAxiosRequestConfig,
  ) {
    return ReadingApiFp(this.configuration)
      .apiReadingIdPut(id, readingItem, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ReadingItem} [readingItem]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReadingApi
   */
  public apiReadingPost(
    readingItem?: ReadingItem,
    options?: RawAxiosRequestConfig,
  ) {
    return ReadingApiFp(this.configuration)
      .apiReadingPost(readingItem, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReadingApi
   */
  public getReadings(options?: RawAxiosRequestConfig) {
    return ReadingApiFp(this.configuration)
      .getReadings(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TodoApi - axios parameter creator
 * @export
 */
export const TodoApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiTodoIdDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiTodoIdDelete', 'id', id);
      const localVarPath = `/api/Todo/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiTodoIdGet: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiTodoIdGet', 'id', id);
      const localVarPath = `/api/Todo/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {TodoItem} [todoItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiTodoIdPut: async (
      id: string,
      todoItem?: TodoItem,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiTodoIdPut', 'id', id);
      const localVarPath = `/api/Todo/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        todoItem,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {TodoItem} [todoItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiTodoPost: async (
      todoItem?: TodoItem,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/Todo`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        todoItem,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTodos: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/Todo`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TodoApi - functional programming interface
 * @export
 */
export const TodoApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TodoApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiTodoIdDelete(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiTodoIdDelete(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TodoApi.apiTodoIdDelete']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiTodoIdGet(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TodoItem>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiTodoIdGet(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TodoApi.apiTodoIdGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {TodoItem} [todoItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiTodoIdPut(
      id: string,
      todoItem?: TodoItem,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiTodoIdPut(
        id,
        todoItem,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TodoApi.apiTodoIdPut']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {TodoItem} [todoItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiTodoPost(
      todoItem?: TodoItem,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiTodoPost(
        todoItem,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TodoApi.apiTodoPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllTodos(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<TodoItem>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllTodos(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TodoApi.getAllTodos']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * TodoApi - factory interface
 * @export
 */
export const TodoApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TodoApiFp(configuration);
  return {
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiTodoIdDelete(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .apiTodoIdDelete(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiTodoIdGet(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<TodoItem> {
      return localVarFp
        .apiTodoIdGet(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {TodoItem} [todoItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiTodoIdPut(
      id: string,
      todoItem?: TodoItem,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .apiTodoIdPut(id, todoItem, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {TodoItem} [todoItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiTodoPost(
      todoItem?: TodoItem,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .apiTodoPost(todoItem, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTodos(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<TodoItem>> {
      return localVarFp
        .getAllTodos(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TodoApi - object-oriented interface
 * @export
 * @class TodoApi
 * @extends {BaseAPI}
 */
export class TodoApi extends BaseAPI {
  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TodoApi
   */
  public apiTodoIdDelete(id: string, options?: RawAxiosRequestConfig) {
    return TodoApiFp(this.configuration)
      .apiTodoIdDelete(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TodoApi
   */
  public apiTodoIdGet(id: string, options?: RawAxiosRequestConfig) {
    return TodoApiFp(this.configuration)
      .apiTodoIdGet(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {TodoItem} [todoItem]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TodoApi
   */
  public apiTodoIdPut(
    id: string,
    todoItem?: TodoItem,
    options?: RawAxiosRequestConfig,
  ) {
    return TodoApiFp(this.configuration)
      .apiTodoIdPut(id, todoItem, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {TodoItem} [todoItem]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TodoApi
   */
  public apiTodoPost(todoItem?: TodoItem, options?: RawAxiosRequestConfig) {
    return TodoApiFp(this.configuration)
      .apiTodoPost(todoItem, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TodoApi
   */
  public getAllTodos(options?: RawAxiosRequestConfig) {
    return TodoApiFp(this.configuration)
      .getAllTodos(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * WeatherApi - axios parameter creator
 * @export
 */
export const WeatherApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} [city]
     * @param {number} [days]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiWeatherForecastGet: async (
      city?: string,
      days?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/Weather/forecast`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (city !== undefined) {
        localVarQueryParameter['city'] = city;
      }

      if (days !== undefined) {
        localVarQueryParameter['days'] = days;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WeatherApi - functional programming interface
 * @export
 */
export const WeatherApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WeatherApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} [city]
     * @param {number} [days]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiWeatherForecastGet(
      city?: string,
      days?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiWeatherForecastGet(
          city,
          days,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['WeatherApi.apiWeatherForecastGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * WeatherApi - factory interface
 * @export
 */
export const WeatherApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = WeatherApiFp(configuration);
  return {
    /**
     *
     * @param {string} [city]
     * @param {number} [days]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiWeatherForecastGet(
      city?: string,
      days?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .apiWeatherForecastGet(city, days, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * WeatherApi - object-oriented interface
 * @export
 * @class WeatherApi
 * @extends {BaseAPI}
 */
export class WeatherApi extends BaseAPI {
  /**
   *
   * @param {string} [city]
   * @param {number} [days]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WeatherApi
   */
  public apiWeatherForecastGet(
    city?: string,
    days?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return WeatherApiFp(this.configuration)
      .apiWeatherForecastGet(city, days, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
